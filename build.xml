<?xml version="1.0" encoding="UTF-8"?>

<project name="sabbus" default="build" xmlns:artifact="urn:maven-artifact-ant">
  <description>
SuperSabbus for Scala core, builds the scala library and compiler. It can also package it as a simple distribution, tests it for stable bootstrapping and against the Scala test suite.
  </description>

<!-- ===========================================================================
END-USER TARGETS
============================================================================ -->

  <target name="build" depends="pack.bin"
    description="Builds the Scala compiler and library. Executables are in 'build/pack/bin'."/>

  <target name="build-opt"
    description="Builds the optimised Scala compiler and library. Executables are in 'build/pack/bin'.">
    <antcall target="build">
      <param name="scalac.args.optimise" value="-optimise"/>
    </antcall>
  </target>

  <target name="clean" depends="quick.clean"
    description="Removes binaries of compiler and library. Distributions are untouched."/>

  <target name="fastlocker" description="Buildlocker without extra fuss">
    <antcall target="locker.unlock"/>
    <antcall target="locker.done"/>
  </target>

<!-- ===========================================================================
PROPERTIES
============================================================================ -->

  <property environment="env"/>
  <!-- Prevents system classpath from being used -->
  <property name="build.sysclasspath" value="ignore"/>

  <!-- Defines the repository layout -->
  <property name="lib.dir" value="${basedir}/lib"/>
  <property name="src.dir" value="${basedir}/src"/>
  <property name="resource.dir" value="${src.dir}/resources"/>

  <!-- For developers: any jars placed in this dir will be added to the classpath
       of all targets and copied into quick/pack/etc builds. -->
  <property name="lib-extra.dir" value="${lib.dir}/extra"/>

  <!-- Loads custom properties definitions -->
  <property file="${basedir}/build.properties"/>
  <!-- Generating version number -->
  <property file="${basedir}/build.number"/>

  <!-- Additional command line arguments for scalac. They are added to all build targets -->
  <property name="scalac.args" value=""/>
  <property name="javac.args" value=""/>

  <!-- Sets location of pre-compiled libraries -->
  <property name="lib.starr.jar" value="${lib.dir}/scala-library.jar"/>
  <property name="reflect.starr.jar" value="${lib.dir}/scala-reflect.jar"/>
  <property name="comp.starr.jar" value="${lib.dir}/scala-compiler.jar"/>
  <property name="ant.jar" value="${ant.home}/lib/ant.jar"/>
  <property name="forkjoin.jar" value="${lib.dir}/forkjoin.jar"/>
  <property name="scala-xml.jar" value="${lib.dir}/scala-xml.jar"/>

  <!-- Sets location of build folders -->
  <property name="build.dir" value="${basedir}/build"/>
  <property name="build-asm.dir" value="${build.dir}/asm"/>
  <property name="build-locker.dir" value="${build.dir}/locker"/>
  <property name="build-quick.dir" value="${build.dir}/quick"/>
  <property name="build-pack.dir" value="${build.dir}/pack"/>
  <property name="locker-library.dir" value="${build-locker.dir}/classes/library"/>
  <property name="locker-reflect.dir" value="${build-locker.dir}/classes/reflect"/>
  <property name="locker-compiler.dir" value="${build-locker.dir}/classes/compiler"/>
  <property name="quick-repl.dir" value="${build-quick.dir}/classes/repl"/>
  <property name="quick-library.dir" value="${build-quick.dir}/classes/library"/>
  <property name="quick-reflect.dir" value="${build-quick.dir}/classes/reflect"/>
  <property name="quick-compiler.dir" value="${build-quick.dir}/classes/compiler"/>

  <property name="dists.dir" value="${basedir}/dists"/>
  <property name="copyright.string" value="Copyright 2002-2011, LAMP/EPFL"/>

  <!-- These are NOT the flags used to run SuperSabbus, but the ones written
       into the script runners created with scala.tools.ant.ScalaTool -->
  <property name="java.flags" value="-Xmx1024m -Xms64m -XX:MaxPermSize=192m"/>
  <property name="jvm.opts" value=""/>

  <!-- if ANT_OPTS is already set by the environment, it will be unaltered,
       but if it is unset it will take this default value. -->
  <property name="env.ANT_OPTS" value="-Xms1536M -Xmx1536M -Xss1M -XX:MaxPermSize=192M -XX:+UseParallelGC" />

  <property
      name="scalacfork.jvmargs"
      value="${env.ANT_OPTS} ${jvm.opts}"/>

<!-- ===========================================================================
INITIALISATION
============================================================================ -->

  <target name="init.jars.check">
    <uptodate property="lib.jars.uptodate">
      <srcfiles dir="${basedir}">
        <include name="lib/**/*.desired.sha1"/>
        <include name="tools/**/*.desired.sha1"/>
      </srcfiles>
      <mapper type="glob" from="*.desired.sha1" to="*"/>
    </uptodate>
  </target>

  <target name="init.jars" depends="init.jars.check" unless="lib.jars.uptodate">
    <echo level="warn" message="Updating bootstrap libs.  (To do this by hand, run ./pull-binary-libs.sh)"/>
    <exec osfamily="unix" vmlauncher="false" executable="./pull-binary-libs.sh" failifexecutionfails="true" />
    <exec osfamily="windows" vmlauncher="false" executable="pull-binary-libs.sh" failifexecutionfails="true" />
    <!-- uptodate task needs to know these are what's in the sha. -->
    <touch>
      <fileset dir="${basedir}">
        <include name="lib/**/*.desired.sha1"/>
        <include name="tools/**/*.desired.sha1"/>
      </fileset>
      <mapper type="glob" from="*.desired.sha1" to="*"/>
    </touch>
  </target>

  <!-- Add our maven ant tasks -->
  <target name="init.maven.tasks" depends="init.jars.check" unless="init.maven.tasks.finished">
    <path id="maven-ant-tasks.classpath" path="${lib.dir}/ant/maven-ant-tasks-2.1.1.jar" />
    <typedef resource="org/apache/maven/artifact/ant/antlib.xml" uri="urn:maven-artifact-ant" classpathref="maven-ant-tasks.classpath" />

    <property name="init.maven.tasks.finished" value="true" />
  </target>

  <!-- Resolve maven dependencies -->
  <target name="init.maven.jars" depends="init.maven.tasks">
    <artifact:dependencies pathId="dependency.classpath" filesetId="dependency.fileset">
      <dependency groupId="com.typesafe" artifactId="config" version="0.4.0"/>
      <dependency groupId="jline" artifactId="jline" version="2.7" />
      <!-- <dependency groupId="com.typesafe.akka" artifactId="akka-actor" version="2.0.2"/> -->
      <!-- <dependency groupId="org.improving" artifactId="jvminfo" version="0.1.1" /> -->
    </artifact:dependencies>
  </target>

  <!-- Determines OSGi string + maven extension. -->
  <target name="init.hasbuildnum">
    <condition property="version.hasbuildnum">
      <not><equals arg1="${version.bnum}" arg2="0"/></not>
    </condition>
  </target>
  <target name="init.build.snapshot" unless="build.release">
    <property name="maven.version.suffix" value="-SNAPSHOT"/>
  </target>
  <target name="init.build.release" if="build.release" depends="init.hasbuildnum, init.build.snapshot">
    <property name="maven.version.suffix" value=""/>
  </target>
  <target name="init.build.nopatch.release" unless="version.hasbuildnum" depends="init.hasbuildnum">
    <property name="version.suffix" value=""/>
  </target>
  <!-- funny thing, ant is.  Can only specify *one* property in if check.  Guaranteed that both are true here,
       since properties are immutable.  -->
  <target name="init.build.patch.release" if="version.hasbuildnum" depends="init.build.nopatch.release">
    <property name="version.suffix" value="-${version.bnum}"/>
  </target>

  <target name="init.hasmavensuffix" if="build.release" depends="init.build.patch.release, init.build.release">
    <condition property="version.hasmavensuffix">
      <not><equals arg1="${maven.version.suffix}" arg2=""/></not>
    </condition>
  </target>

  <target name="init.osgi.suffix" if="version.hasmavensuffix" depends="init.hasmavensuffix">
    <property name="osgi.version.suffix" value="${maven.version.suffix}"/>
  </target>

  <target name="init.osgi.suffix.final" if="build.release" unless="version.hasmavensuffix" depends="init.hasmavensuffix">
    <property name="osgi.version.suffix" value="-VFINAL"/>
  </target>


  <target name="init.osgi.suffix.snapshot" unless="build.release" depends="init.hasmavensuffix">
    <property name="osgi.version.suffix" value=""/>
  </target>

  <target name="init.build.suffix.done" depends="init.build.release, init.build.patch.release, init.osgi.suffix, init.osgi.suffix.final, init.osgi.suffix.snapshot"/>

  <target name="init.version.git" depends="init.build.suffix.done">
    <!-- Find out whether we are running on Windows -->
    <condition property="os.win">
      <os family="windows"/>
    </condition>

    <exec osfamily="unix" executable="tools/get-scala-commit-sha" outputproperty="git.commit.sha" failifexecutionfails="false" />
    <exec osfamily="windows" executable="cmd.exe" outputproperty="git.commit.sha" failifexecutionfails="false">
      <arg value="/c"/>
      <arg value="tools\get-scala-commit-sha.bat"/>
      <arg value="-p"/>
    </exec>
    <exec osfamily="unix" executable="tools/get-scala-commit-date" outputproperty="git.commit.date" failifexecutionfails="false" />
    <exec osfamily="windows" executable="cmd.exe" outputproperty="git.commit.date" failifexecutionfails="false">
      <arg value="/c"/>
      <arg value="tools\get-scala-commit-date.bat"/>
      <arg value="-p"/>
    </exec>
    <!-- some default in case something went wrong getting the revision -->
    <property name="git.commit.sha" value="unknown"/>
    <property name="git.commit.date" value="unknown"/>

    <!-- We use the git describe to determine the OSGi modifier for our build. -->
    <property
      name="maven.version.number"
      value="${version.major}.${version.minor}.${version.patch}${version.suffix}${maven.version.suffix}"/>
    <property
      name="osgi.version.number"
      value="${version.major}.${version.minor}.${version.patch}.v${git.commit.date}${version.suffix}${osgi.version.suffix}-${git.commit.sha}"/>
  </target>

  <target name="init.version.snapshot" unless="build.release" depends="init.version.git">
     <property
      name="version.number"
      value="${version.major}.${version.minor}.${version.patch}${version.suffix}-${git.commit.date}-${git.commit.sha}"/>
  </target>

  <target name="init.version.release" if="build.release" depends="init.version.git">
     <property
      name="version.number"
      value="${maven.version.number}"/>
  </target>

  <target name="init.version.done" depends="init.version.release, init.version.snapshot"/>

  <target name="init.testjava6">
      <condition property="has.java6">
          <equals arg1="${ant.java.version}" arg2="1.6"/>
      </condition>
      <condition property="has.java7">
          <equals arg1="${ant.java.version}" arg2="1.7"/>
      </condition>
      <condition property="has.unsupported.jdk">
         <not><or>
           <isset property="has.java7" />
           <isset property="has.java6" />
         </or></not>
      </condition>
  </target>

  <target name="init.fail.bad.jdk" depends="init.testjava6">
    <fail if="has.unsupported.jdk"
          message="JDK ${ant.java.version} is not supported by this build!"/>
  </target>
  <target name="init.warn.jdk7" depends="init.testjava6" if="has.java7">
     <echo level="warning"> You are using JDK7 for this build.  While this will be able to build most of Scala, it will
       not build the Swing project.   You will be unable to create a distribution.
     </echo>
  </target>

  <target name="init" depends="init.jars, init.maven.jars, init.version.done, init.fail.bad.jdk, init.warn.jdk7">
    <property name="scalac.args.always" value="" />
  <!-- scalac.args.optimise is selectively overridden in certain antcall tasks. -->
    <property name="scalac.args.optimise" value=""/>
  <!-- scalac.args.quickonly are added to quick.* targets but not others (particularly, locker.)
       This is to facilitate testing new command line options which do not yet exist in starr.
       Note: These are also used by strap since they may affect JVM target or other and we'd like
       to be able to test binary stability of features. -->
    <property name="scalac.args.quickonly" value=""/>
    <property name="scalac.args.all" value="${scalac.args.always} ${scalac.args} ${scalac.args.optimise}"/>
    <property name="scalac.args.quick" value="${scalac.args.all} ${scalac.args.quickonly}"/>
    <!-- Setting-up Ant contrib tasks -->
    <taskdef resource="net/sf/antcontrib/antlib.xml" classpath="${lib.dir}/ant/ant-contrib.jar"/>
    <!-- This is the start time for the distribution -->
    <tstamp prefix="time">
      <format property="human" pattern="d MMMM yyyy, HH:mm:ss" locale="en,US"/>
      <format property="short" pattern="yyyyMMddHHmmss"/>
    </tstamp>

    <!-- some default in case something went wrong getting the revision -->
    <property name="version.number" value="-unknown-"/>
    <property name="init.avail" value="yes"/>

    <!-- Local libs (developer use.) -->
    <mkdir dir="${lib-extra.dir}"/>

    <path id="lib.extra">
      <fileset dir="${lib-extra.dir}" erroronmissingdir="false" />
    </path>

    <!-- Auxiliary libs placed on every classpath. -->
    <path id="aux.libs">
      <pathelement location="${forkjoin.jar}"/>
      <pathelement location="${scala-xml.jar}"/>
      <pathelement location="${ant.jar}"/>
      <pathelement location="${build-asm.dir}/classes"/>
      <path refid="lib.extra"/>
      <path refid="dependency.classpath"/>
    </path>

    <!-- And print-out what we are building -->
    <echo message="       build time: ${time.human}" />
    <echo message="     java version: ${java.vm.name} ${java.version} (${ant.java.version})" />
    <echo message="        java args: ${env.ANT_OPTS} ${jvm.opts}" />
    <echo message="       javac args: ${javac.args}" />
    <echo message="      scalac args: ${scalac.args.all}" />
    <echo message="scalac quick args: ${scalac.args.quick}" />
    <echo message="         git date: ${git.commit.date}" />
    <echo message="         git hash: ${git.commit.sha}" />
    <echo message="    maven version: ${maven.version.number}"/>
    <echo message="     OSGi version: ${osgi.version.number}" />
    <echo message="canonical version: ${version.number}" />

  <!-- When building each stage, the classpath used to run the compiler
  (given to the scalacfork task as "compilerpathref") is the classpath
  from the previous stage.  The classpath actually given to the compiler
  during that build (given to the scalacfork task as "compilationpath")
  is the classpath from that stage.
  
    When building locker: compilerpathref=starr.classpath, compilationpath=locker.classpath
    When building quick: compilerpathref=locker.classpath, compilationpath=quick.classpath
    When building strap: compilerpathref=pack.classpath, compilationpath=strap.classpath

  -->
    <path id="starr.classpath">
      <pathelement location="${lib.starr.jar}"/>
      <pathelement location="${reflect.starr.jar}"/>
      <pathelement location="${comp.starr.jar}"/>
      <path refid="aux.libs"/>
    </path>
    <path id="locker.classpath">
      <pathelement location="${locker-library.dir}"/>
      <pathelement location="${locker-reflect.dir}"/>
      <pathelement location="${locker-compiler.dir}"/>
      <path refid="aux.libs"/>
    </path>
    <path id="quick.classpath">
      <pathelement location="${quick-library.dir}"/>
      <pathelement location="${quick-reflect.dir}"/>
      <pathelement location="${quick-compiler.dir}"/>
      <pathelement location="${quick-repl.dir}"/>
      <path refid="aux.libs"/>
    </path>
    <path id="pack.classpath">
      <fileset dir="${build-pack.dir}/lib" erroronmissingdir="false"/>
    </path>

    <echo message="starr.classpath: ${toString:starr.classpath}" />
    <echo message="locker.classpath: ${toString:locker.classpath}" />
    <echo message="quick.classpath: ${toString:quick.classpath}" />
    <echo message="pack.classpath: ${toString:pack.classpath}" />

    <taskdef resource="scala/tools/ant/sabbus/antlib.xml" classpathref="starr.classpath"/>
  </target>

<!-- ===========================================================================
LOCAL Adapted ASM
============================================================================ -->

  <target name="asm.start" depends="init">
    <condition property="asm.available">
      <available file="${build-asm.dir}/asm.complete"/>
    </condition>
  </target>

  <target name="asm.clean" depends="init">
    <delete dir="${build-asm.dir}" includeemptydirs="yes" quiet="yes" failonerror="no"/>
  </target>

  <target name="asm.lib" depends="asm.start" unless="asm.available">
    <stopwatch name="asm.lib.timer"/>
    <mkdir dir="${build-asm.dir}/classes/"/>
    <javac
      srcdir="${src.dir}/asm"
      destdir="${build-asm.dir}/classes"
      classpath="${build-asm.dir}/classes"
      includes="**/*.java"
      target="1.6" source="1.6">
        <compilerarg line="${javac.args} -XDignore.symbol.file"/>
    </javac>
    <touch file="${build-asm.dir}/asm.complete" verbose="no"/>
    <stopwatch name="asm.lib.timer" action="total"/>
  </target>

  <target name="asm.done" depends="asm.lib" />

<!-- ===========================================================================
LOCAL REFERENCE BUILD (LOCKER)
============================================================================ -->

  <target name="locker.start" depends="asm.done">
    <condition property="locker.available">
      <available file="${build-locker.dir}/all.complete"/>
    </condition>
  </target>

  <target name="locker.pre-lib" depends="locker.start" unless="locker.available">
    <condition property="locker.lib.needed">
      <not><available file="${build-locker.dir}/library.complete"/></not>
    </condition>
  </target>

  <target name="locker.lib" depends="locker.pre-lib" if="locker.lib.needed">
    <stopwatch name="locker.lib.timer"/>
    <mkdir dir="${locker-library.dir}"/>
    <javac
      srcdir="${src.dir}/library"
      destdir="${locker-library.dir}"
      classpath="${locker-library.dir}"
      includes="**/*.java"
      target="1.6" source="1.6">
        <compilerarg line="${javac.args} -XDignore.symbol.file"/>
    </javac>
    <!-- NOTE: Potential problem with maximal command line length on Windows
         (32768 characters for XP, since executed with Java's "exec"). See
         src/build/msil.xml in msil branch for more details. -->
    <scalacfork
      destdir="${locker-library.dir}"
      compilerpathref="starr.classpath"
      srcpath="${src.dir}/library"
      params="${scalac.args.all}"
      srcdir="${src.dir}/library"
      jvmargs="${scalacfork.jvmargs}">
      <include name="**/*.scala"/>
      <compilationpath>
        <pathelement location="${locker-library.dir}"/>
        <path refid="aux.libs"/>
      </compilationpath>
    </scalacfork>
    <propertyfile file="${locker-library.dir}/library.properties">
      <entry key="version.number" value="${version.number}"/>
      <entry key="maven.version.number" value="${maven.version.number}"/>
      <entry key="osgi.version.number" value="${osgi.version.number}"/>
      <entry key="copyright.string" value="${copyright.string}"/>
    </propertyfile>
    <touch file="${build-locker.dir}/library.complete" verbose="no"/>
    <stopwatch name="locker.lib.timer" action="total"/>
  </target>

  <target name="locker.pre-reflect" depends="locker.lib" unless="locker.available">
    <condition property="locker.reflect.needed">
      <not><available file="${build-locker.dir}/reflect.complete"/></not>
    </condition>
  </target>

  <target name="locker.reflect" depends="locker.pre-reflect" if="locker.reflect.needed">
    <stopwatch name="locker.reflect.timer"/>
    <mkdir dir="${locker-reflect.dir}"/>
    <scalacfork
      destdir="${locker-reflect.dir}"
      compilerpathref="starr.classpath"
      params="${scalac.args.all}"
      srcdir="${src.dir}/reflect"
      jvmargs="${scalacfork.jvmargs}">
      <include name="**/*.scala"/>
      <compilationpath>
        <pathelement location="${locker-library.dir}"/>
        <pathelement location="${locker-reflect.dir}"/>
        <path refid="aux.libs"/>
      </compilationpath>
    </scalacfork>
    <touch file="${build-locker.dir}/reflect.complete" verbose="no"/>
    <stopwatch name="locker.reflect.timer" action="total"/>
  </target>

  <target name="locker.pre-comp" depends="locker.reflect" unless="locker.available">
    <condition property="locker.comp.needed">
      <not><available file="${build-locker.dir}/compiler.complete"/></not>
    </condition>
  </target>

  <target name="locker.comp" depends="locker.pre-comp" if="locker.comp.needed">
    <stopwatch name="locker.comp.timer"/>
    <mkdir dir="${locker-compiler.dir}"/>
    <!-- TODO If we have cross dependencies, move this below scalacfork... -->
    <javac
      srcdir="${src.dir}/compiler"
      destdir="${locker-compiler.dir}"
      includes="**/*.java"
      target="1.6" source="1.6">
        <compilerarg line="${javac.args}"/>
        <classpath refid="locker.classpath"/>
    </javac>
    <scalacfork
      destdir="${locker-compiler.dir}"
      compilerpathref="starr.classpath"
      params="${scalac.args.all}"
      srcdir="${src.dir}/compiler"
      jvmargs="${scalacfork.jvmargs}">
      <include name="**/*.scala"/>
      <compilationpath>
        <pathelement location="${locker-library.dir}"/>
        <pathelement location="${locker-reflect.dir}"/>
        <pathelement location="${locker-compiler.dir}"/>
        <path refid="aux.libs"/>
      </compilationpath>
    </scalacfork>
    <propertyfile file="${locker-compiler.dir}/compiler.properties">
      <entry key="version.number" value="${version.number}"/>
      <entry key="maven.version.number" value="${maven.version.number}"/>
      <entry key="osgi.version.number" value="${osgi.version.number}"/>
      <entry key="copyright.string" value="${copyright.string}"/>
    </propertyfile>
    <copy todir="${locker-compiler.dir}">
      <fileset dir="${src.dir}/compiler">
        <include name="**/*.tmpl"/>         <!-- runners -->
        <include name="**/*.xml"/>          <!-- antlib.xml -->
        <include name="**/*.properties"/>   <!-- compiler.properties -->
      </fileset>
    </copy>
    <touch file="${build-locker.dir}/compiler.complete" verbose="no"/>
    <stopwatch name="locker.comp.timer" action="total"/>
  </target>

  <target name="locker.done" depends="locker.comp">
    <touch file="${build-locker.dir}/all.complete" verbose="no"/>
  </target>

  <target name="locker.clean">
    <delete dir="${build-locker.dir}" includeemptydirs="yes" quiet="yes" failonerror="no"/>
  </target>

  <target name="locker.unlock.pre-lib">
    <uptodate property="locker.lib.available" targetfile="${build-locker.dir}/library.complete">
      <srcfiles dir="${src.dir}">
        <include name="library/**"/>
      </srcfiles>
    </uptodate>
  </target>

  <target name="locker.unlock.lib" depends="locker.unlock.pre-lib" unless="locker.lib.available">
    <delete file="${build-locker.dir}/library.complete"/>
  </target>

  <target name="locker.unlock.pre-reflect" depends="locker.unlock.lib">
    <uptodate property="locker.reflect.available" targetfile="${build-locker.dir}/reflect.complete">
      <srcfiles dir="${src.dir}">
        <include name="reflect/**"/>
      </srcfiles>
    </uptodate>
  </target>

  <target name="locker.unlock.reflect" depends="locker.unlock.pre-reflect" unless="locker.reflect.available">
    <delete file="${build-locker.dir}/reflect.complete"/>
  </target>

  <target name="locker.unlock.pre-comp" depends="locker.unlock.reflect">
    <uptodate property="locker.comp.available" targetfile="${build-locker.dir}/compiler.complete">
      <srcfiles dir="${src.dir}">
        <include name="compiler/**"/>
      </srcfiles>
    </uptodate>
  </target>

  <target name="locker.unlock.comp" depends="locker.unlock.pre-comp" unless="locker.comp.available">
    <delete file="${build-locker.dir}/compiler.complete"/>
  </target>

  <target name="locker.unlock" depends="locker.unlock.comp">
    <delete file="${build-locker.dir}/*.complete" />
  </target>

<!-- ===========================================================================
QUICK BUILD (QUICK)
============================================================================ -->

  <target name="quick.start" depends="locker.done"/>

  <target name="quick.pre-lib" depends="quick.start">
    <uptodate property="quick.lib.available" targetfile="${build-quick.dir}/library.complete">
      <srcfiles dir="${src.dir}">
        <include name="library/**"/>
      </srcfiles>
    </uptodate>
  </target>

  <target name="quick.lib" depends="quick.pre-lib" unless="quick.lib.available">
    <stopwatch name="quick.lib.timer"/>
    <mkdir dir="${quick-library.dir}"/>
    <javac
      srcdir="${src.dir}/library"
      destdir="${quick-library.dir}"
      classpath="${quick-library.dir}"
      includes="**/*.java"
      target="1.6" source="1.6">
      <compilerarg line="${javac.args} -XDignore.symbol.file"/>
    </javac>
    <scalacfork
      destdir="${quick-library.dir}"
      compilerpathref="locker.classpath"
      srcpath="${src.dir}/library"
      params="${scalac.args.quick}"
      srcdir="${src.dir}/library"
      jvmargs="${scalacfork.jvmargs}">
      <include name="**/*.scala"/>
      <compilationpath>
        <pathelement location="${quick-library.dir}"/>
        <path refid="aux.libs"/>
      </compilationpath>
    </scalacfork>
    <propertyfile file="${quick-library.dir}/library.properties">
      <entry key="version.number" value="${version.number}"/>
      <entry key="maven.version.number" value="${maven.version.number}"/>
      <entry key="osgi.version.number" value="${osgi.version.number}"/>
      <entry key="copyright.string" value="${copyright.string}"/>
    </propertyfile>
    <copy todir="${quick-library.dir}">
      <fileset dir="${src.dir}/library">
        <include name="**/*.properties"/>
      </fileset>
    </copy>
    <touch file="${build-quick.dir}/library.complete" verbose="no"/>
    <stopwatch name="quick.lib.timer" action="total"/>
  </target>

  <target name="quick.pre-reflect" depends="quick.lib">
    <uptodate property="quick.reflect.available" targetfile="${build-quick.dir}/reflect.complete">
      <srcfiles dir="${src.dir}">
        <include name="reflect/**"/>
      </srcfiles>
    </uptodate>
  </target>

  <target name="quick.reflect" depends="quick.pre-reflect" unless="quick.reflect.available">
    <stopwatch name="quick.reflect.timer"/>
    <mkdir dir="${quick-reflect.dir}"/>
    <scalacfork
      destdir="${quick-reflect.dir}"
      compilerpathref="locker.classpath"
      params="${scalac.args.all}"
      srcdir="${src.dir}/reflect"
      jvmargs="${scalacfork.jvmargs}">
      <include name="**/*.scala"/>
      <compilationpath>
        <pathelement location="${quick-library.dir}"/>
        <pathelement location="${quick-reflect.dir}"/>
        <path refid="aux.libs"/>
      </compilationpath>
    </scalacfork>
    <touch file="${build-quick.dir}/reflect.complete" verbose="no"/>
    <stopwatch name="quick.reflect.timer" action="total"/>
  </target>

  <target name="quick.pre-comp" depends="quick.reflect">
    <uptodate property="quick.comp.available" targetfile="${build-quick.dir}/compiler.complete">
      <srcfiles dir="${src.dir}">
        <include name="compiler/**"/>
      </srcfiles>
    </uptodate>
  </target>

  <target name="quick.comp" depends="quick.pre-comp" unless="quick.comp.available">
    <stopwatch name="quick.comp.timer"/>
    <mkdir dir="${quick-compiler.dir}"/>
    <!-- TODO If we have cross dependencies, move this below scalacfork... -->
    <javac
      srcdir="${src.dir}/compiler"
      destdir="${quick-compiler.dir}"
      includes="**/*.java"
      target="1.6" source="1.6">
        <compilerarg line="${javac.args}"/>
        <classpath refid="locker.classpath"/>
    </javac>
    <scalacfork
      destdir="${quick-compiler.dir}"
      compilerpathref="locker.classpath"
      params="${scalac.args.quick}"
      srcdir="${src.dir}/compiler"
      jvmargs="${scalacfork.jvmargs}">
      <include name="**/*.scala"/>
      <compilationpath>
        <pathelement location="${quick-library.dir}"/>
        <pathelement location="${quick-reflect.dir}"/>
        <pathelement location="${quick-compiler.dir}"/>
        <path refid="aux.libs"/>
      </compilationpath>
    </scalacfork>
    <propertyfile file="${quick-compiler.dir}/compiler.properties">
      <entry key="version.number" value="${version.number}"/>
      <entry key="maven.version.number" value="${maven.version.number}"/>
      <entry key="osgi.version.number" value="${osgi.version.number}"/>
      <entry key="copyright.string" value="${copyright.string}"/>
    </propertyfile>
    <copy todir="${quick-compiler.dir}">
      <fileset dir="${src.dir}/compiler">
        <include name="**/*.tmpl"/>         <!-- runners -->
        <include name="**/*.xml"/>          <!-- antlib.xml -->
        <include name="**/*.properties"/>   <!-- compiler.properties -->
      </fileset>
    </copy>
    <touch file="${build-quick.dir}/compiler.complete" verbose="no"/>
    <stopwatch name="quick.comp.timer" action="total"/>
  </target>

  <target name="quick.pre-repl" depends="quick.comp">
    <uptodate property="quick.repl.available" targetfile="${build-quick.dir}/repl.complete">
      <srcfiles dir="${src.dir}">
        <include name="repl/**"/>
      </srcfiles>
    </uptodate>
  </target>

  <target name="quick.repl" depends="quick.pre-repl" unless="quick.repl.available">
    <stopwatch name="quick.repl.timer"/>
    <mkdir dir="${quick-repl.dir}"/>
    <scalacfork
      destdir="${quick-repl.dir}"
      compilerpathref="locker.classpath"
      srcpath="${src.dir}/repl"
      params="${scalac.args.quick}"
      srcdir="${src.dir}/repl"
      jvmargs="${scalacfork.jvmargs}">
      <include name="**/*.scala"/>
      <compilationpath refid="quick.classpath"/>
    </scalacfork>
    <touch file="${build-quick.dir}/repl.complete" verbose="no"/>
    <stopwatch name="quick.repl.timer" action="total"/>
  </target>

  <target name="quick.done" depends="quick.repl" />
  
  <target name="all.touch">
    <delete><fileset dir="${build.dir}" includes="**/*.complete"/></delete>
  </target>

  <target name="refresh" description="Unlock locker and remove all *.complete files, then build normally.">
    <antcall target="unlocklocker"/>
    <antcall target="all.touch"/>
    <antcall target="build"/>
  </target>

  <target name="rebuild" description="Remove the quick *.complete files, then build normally.">
    <antcall target="quick.touch"/>
    <antcall target="build"/>
  </target>

  <target name="quick.touch">
    <delete><fileset dir="${build-quick.dir}" includes="*.complete"/></delete>
  </target>

  <target name="quick.clean">
    <delete dir="${build-quick.dir}" includeemptydirs="yes" quiet="yes" failonerror="no"/>
  </target>

<!-- ===========================================================================
PACKED QUICK BUILD (PACK)
============================================================================ -->

  <target name="pack.start" depends="quick.done"/>

  <target name="pack.pre-lib" depends="pack.start">
    <uptodate
      property="pack.lib.available"
      targetfile="${build-pack.dir}/lib/scala-library.jar"
      srcfile="${build-quick.dir}/library.complete"/>
  </target>

  <target name="pack.lib" depends="pack.pre-lib" unless="pack.lib.available">
    <mkdir dir="${build-pack.dir}/lib"/>
    <!-- First copy maven dependencies -->
    <copy todir="${build-pack.dir}/lib">
      <fileset refid="dependency.fileset" />
      <mapper type="flatten" />
    </copy>
    <!-- <jar
      encoding="UTF-8"
      compress="true"
      keepcompression="true"
      level="5"
      index="true"
      update="true"
      destfile="${build-pack.dir}/lib/scala-library.jar">
        <fileset dir="${quick-library.dir}"/>
    </jar> -->
    <jar
      encoding="UTF-8"
      destfile="${build-pack.dir}/lib/scala-library.jar">
        <fileset dir="${quick-library.dir}"/>
    </jar>
    <copy file="${forkjoin.jar}" todir="${build-pack.dir}/lib"/>
  </target>

  <target name="pack.pre-reflect" depends="pack.lib">
    <uptodate
      property="pack.reflect.available"
      targetfile="${build-pack.dir}/lib/scala-reflect.jar"
      srcfile="${build-quick.dir}/reflect.complete"/>
  </target>

  <target name="pack.reflect" depends="pack.pre-reflect" unless="pack.reflect.available">
    <mkdir dir="${build-pack.dir}/lib"/>
    <jar destfile="${build-pack.dir}/lib/scala-reflect.jar">
      <fileset dir="${quick-reflect.dir}" />
    </jar>
  </target>

  <target name="pack.pre-comp" depends="pack.reflect">
    <uptodate
      property="pack.comp.available"
      targetfile="${build-pack.dir}/lib/scala-compiler.jar"
      srcfile="${build-quick.dir}/compiler.complete"/>
  </target>

  <target name="pack.comp" depends="pack.pre-comp" unless="pack.comp.available">
    <mkdir dir="${build-pack.dir}/META-INF"/>
    <copy file="META-INF/MANIFEST.MF" toDir="${build-pack.dir}/META-INF"/>
    <manifest file="${build-pack.dir}/META-INF/MANIFEST.MF" mode="update">
      <attribute name="Bundle-Version" value="${version.number}"/>
    </manifest>
    <mkdir dir="${build-pack.dir}/lib"/>
    <jar
      encoding="UTF-8"
      destfile="${build-pack.dir}/lib/scala-compiler.jar"
      manifest="${build-pack.dir}/META-INF/MANIFEST.MF">
        <fileset dir="${quick-compiler.dir}"/>
    </jar>
    <jar destfile="${build-pack.dir}/lib/scala-asm.jar" manifest="${build-pack.dir}/META-INF/MANIFEST.MF">
      <fileset dir="${build-asm.dir}/classes"/>
    </jar>
    <copy todir="${build-pack.dir}/lib">
      <fileset dir="${lib-extra.dir}">
        <include name="**/*.jar"/>
      </fileset>
    </copy>
  </target>

  <target name="pack.pre-repl" depends="pack.comp">
    <uptodate
      property="pack.repl.available"
      targetfile="${build-pack.dir}/lib/scala-repl.jar"
      srcfile="${build-quick.dir}/repl.complete"/>
  </target>

  <target name="pack.repl" depends="pack.pre-repl" unless="pack.repl.available">
    <mkdir dir="${build-pack.dir}/META-INF"/>
    <copy file="META-INF/MANIFEST.MF" toDir="${build-pack.dir}/META-INF"/>
    <manifest file="${build-pack.dir}/META-INF/MANIFEST.MF" mode="update">
      <attribute name="Bundle-Version" value="${version.number}"/>
    </manifest>
    <mkdir dir="${build-pack.dir}/lib"/>
    <jar destfile="${build-pack.dir}/lib/scala-repl.jar" manifest="${build-pack.dir}/META-INF/MANIFEST.MF">
      <fileset dir="${quick-repl.dir}"/>
    </jar>
  </target>

  <target name="pack.pre-bin" depends="pack.repl">
    <uptodate
      property="pack.bin.available"
      srcfile="${build-pack.dir}/lib/scala-compiler.jar"
      targetfile="${build-pack.dir}/bin.complete"/>
  </target>

  <target name="pack.bin" depends="pack.pre-bin" unless="pack.bin.available">
    <copy file="${resource.dir}/runner.sh" tofile="${build-pack.dir}/bin/scala"/>
    <copy file="${resource.dir}/runner.sh" tofile="${build-pack.dir}/bin/scalac"/>
    <chmod perm="ugo+rx" file="${build-pack.dir}/bin/scala"/>
    <chmod perm="ugo+rx" file="${build-pack.dir}/bin/scalac"/>
    <touch file="${build-pack.dir}/bin.complete" verbose="no"/>
  </target>

  <target name="pack.clean" depends="quick.clean">
    <delete dir="${build-pack.dir}" includeemptydirs="yes" quiet="yes" failonerror="no"/>
  </target>

<!-- ===========================================================================
TEST AND DISTRIBUTION BUNDLE (ALL)
============================================================================ -->

  <property name="dists.dir" value="${basedir}/dists"/>

  <target name="dist" depends="pack.bin">
    <property name="dist.name" value="scala-${version.number}"/>
    <property name="dist.dir" value="${dists.dir}/${dist.name}"/>
    <mkdir dir="${dist.dir}/lib"/>
    <copy toDir="${dist.dir}/lib">
      <fileset dir="${build-pack.dir}/lib"/>
    </copy>
    <mkdir dir="${dist.dir}/bin"/>
    <copy toDir="${dist.dir}/bin">
      <fileset dir="${build-pack.dir}/bin"/>
    </copy>
    <chmod perm="ugo+rx" file="${dist.dir}/bin/scala"/>
    <chmod perm="ugo+rx" file="${dist.dir}/bin/scalac"/>
    <symlink link="${dists.dir}/latest" resource="${dist.name}" overwrite="yes"/>
  </target>
  
  <target name="dist-opt"
    description="Builds an optimised distribution.">
    <antcall target="dist">
      <param name="scalac.args.optimise" value="-optimise"/>
    </antcall>
  </target>

  <target name="dist.clean">
    <delete dir="${dists.dir}" includeemptydirs="yes" quiet="yes" failonerror="no"/>
  </target>

  <target name="all.clean" depends="locker.clean, quick.clean, pack.clean, dist.clean"/>

<!-- ===========================================================================
STABLE REFERENCE (STARR)
============================================================================ -->
<!-- Does not use any properties other than ${basedir}, so that it can
     run without 'init' (when using 'replacestarrwin') -->

  <target name="starr.start" depends="pack.bin"/>

  <target name="starr.copy" depends="starr.start">
    <copy todir="${basedir}/lib">
      <fileset dir="${build-pack.dir}/lib">
        <include name="scala-compiler.jar"/>
        <include name="scala-reflect.jar"/>
        <include name="scala-library.jar"/>
      </fileset>
    </copy>
  </target>

  <target name="starr.clean" depends="starr.start">
    <delete file="${basedir}/lib/scala-library.jar"/>
    <delete file="${basedir}/lib/scala-reflect.jar"/>
    <delete file="${basedir}/lib/scala-compiler.jar"/>
  </target>

  <!-- remove SHA1 files for no starr, so we don't lose artifacts. -->
  <target name="starr.removesha1">
    <delete>
      <fileset dir="${basedir}/lib">
        <include name="scala-compiler.jar.desired.sha1"/>
        <include name="scala-reflect.jar.desired.sha1"/>
        <include name="scala-library.jar.desired.sha1"/>
      </fileset>
    </delete>
  </target>

  <target name="starr" depends="starr.copy, starr.removesha1"/>

  <target name="yourkit.init">
    <property name="yourkit.home" value="/Applications/YourKit.app"/>
    <property name="yourkit.api.jar" value="${yourkit.home}/lib/yjp-controller-api-redist.jar"/>
    <property name="yourkit.agent" value="${yourkit.home}/bin/mac/libyjpagent.jnilib"/>
    <property name="yourkit.jvm.opts" value="-agentpath:${yourkit.agent}"/>
    <property name="yourkit.scalac.opts" value="-Yprofile:all"/>
  </target>

  <!-- Builds yourkit wrapper/jar and copies into lib/extra. -->
  <target name="yourkit.build" depends="locker.done,yourkit.init">
    <copy file="${yourkit.api.jar}" todir="${lib-extra.dir}"/>
    <property name="yourkit.build.dir" value="${build-quick.dir}/classes/yourkit"/>
    <mkdir dir="${yourkit.build.dir}"/>

    <scalacfork
      destdir="${yourkit.build.dir}"
      compilerpathref="locker.classpath"
      params="${scalac.args.all}"
      srcdir="${src.dir}/yourkit"
      jvmargs="${scalacfork.jvmargs}">
      <include name="**/*.scala"/>
      <compilationpath refid="locker.classpath"/>
    </scalacfork>
    <jar destfile="${lib-extra.dir}/scalac-yourkit.jar">
      <fileset dir="${yourkit.build.dir}"/>
    </jar>
  </target>

  <!-- Builds quick.lib/comp with profiling enabled. -->
  <target name="yourkit.run" depends="yourkit.build">
    <antcall target="clean"/>
    <ant target="quick.lib" inheritall="false" inheritrefs="false">
      <property name="jvm.opts" value="${yourkit.jvm.opts}"/>
      <property name="scalac.args" value="${yourkit.scalac.opts}"/>
    </ant>
    <ant target="quick.comp" inheritall="false" inheritrefs="false">
      <property name="jvm.opts" value="${yourkit.jvm.opts}"/>
      <property name="scalac.args" value="${yourkit.scalac.opts}"/>
    </ant>
    <antcall target="build"/>
  </target>
</project>
