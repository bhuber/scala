builder > A.scala B.scala C.scala
compiling Set(A.scala, B.scala, C.scala)
Changes: Map()
builder > A.scala
compiling Set(A.scala)
Changes: Map(class A -> List(), class B -> List(Changed(Class(B))[List((A,Object))]))
invalidate C.scala because parents have changed [Changed(Class(B))[List((A,Object))]]
invalidate B.scala because it references invalid (no longer inherited) definition [ParentChanged(Class(C))]
compiling Set(B.scala, C.scala)
B.scala:3: error: type mismatch;
 found   : C
 required: ?{def x: ?}
Note that implicit conversions are not applicable because they are ambiguous:
 both method Ensuring in object Predef of type [A](__resultOfEnsuring: A)Ensuring[A]
 and method ArrowAssoc in object Predef of type [A](__leftOfArrow: A)ArrowAssoc[A]
 are possible conversion functions from C to ?{def x: ?}
    println( (new C).x )
              ^
